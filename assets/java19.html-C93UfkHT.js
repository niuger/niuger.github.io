import{_ as c}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as e,o as l,c as r,b as n,e as a,d as s,w as i,a as o}from"./app-D1uezr0R.js";const u={},k=n("p",null,"JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。",-1),d=n("p",null,"JDK 19 只有 7 个新特性：",-1),h={href:"https://openjdk.org/jeps/405",target:"_blank",rel:"noopener noreferrer"},m={href:"https://openjdk.org/jeps/422",target:"_blank",rel:"noopener noreferrer"},v={href:"https://openjdk.org/jeps/424",target:"_blank",rel:"noopener noreferrer"},_={href:"https://openjdk.org/jeps/425",target:"_blank",rel:"noopener noreferrer"},g={href:"https://openjdk.java.net/jeps/426",target:"_blank",rel:"noopener noreferrer"},f={href:"https://openjdk.java.net/jeps/427",target:"_blank",rel:"noopener noreferrer"},j={href:"https://openjdk.org/jeps/428",target:"_blank",rel:"noopener noreferrer"},b=n("p",null,"这里只对 424、425、426、428 这 4 个我觉得比较重要的新特性进行详细介绍。",-1),J={href:"https://openjdk.org/projects/jdk/19/",target:"_blank",rel:"noopener noreferrer"},P=n("h2",{id:"jep-424-外部函数和内存-api-预览",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#jep-424-外部函数和内存-api-预览"},[n("span",null,"JEP 424: 外部函数和内存 API（预览）")])],-1),y=n("p",null,"Java 程序可以通过该 API 与 Java 运行时之外的代码和数据进行互操作。通过高效地调用外部函数（即 JVM 之外的代码）和安全地访问外部内存（即不受 JVM 管理的内存），该 API 使 Java 程序能够调用本机库并处理本机数据，而不会像 JNI 那样危险和脆弱。",-1),S={href:"https://openjdk.java.net/jeps/412",target:"_blank",rel:"noopener noreferrer"},A={href:"https://openjdk.org/jeps/419",target:"_blank",rel:"noopener noreferrer"},w={href:"https://openjdk.org/jeps/424",target:"_blank",rel:"noopener noreferrer"},I=n("p",null,"在没有外部函数和内存 API 之前：",-1),E={href:"https://hg.openjdk.java.net/jdk/jdk/file/tip/src/jdk.unsupported/share/classes/sun/misc/Unsafe.java",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"sun.misc.Unsafe",-1),q=n("code",null,"Unsafe",-1),D=n("code",null,"Unsafe",-1),L={href:"https://www.baeldung.com/jni",target:"_blank",rel:"noopener noreferrer"},T={href:"https://github.com/java-native-access/jna",target:"_blank",rel:"noopener noreferrer"},M={href:"https://github.com/jnr/jnr-ffi",target:"_blank",rel:"noopener noreferrer"},N={href:"https://github.com/bytedeco/javacpp",target:"_blank",rel:"noopener noreferrer"},V=o(`<p>引入外部函数和内存 API 就是为了解决 Java 访问外部函数和外部内存存在的一些痛点。</p><p>Foreign Function &amp; Memory API (FFM API) 定义了类和接口：</p><ul><li>分配外部内存 ：<code>MemorySegment</code>、、<code>MemoryAddress</code>和<code>SegmentAllocator</code>）；</li><li>操作和访问结构化的外部内存： <code>MemoryLayout</code>, <code>VarHandle</code>；</li><li>控制外部内存的分配和释放：<code>MemorySession</code>；</li><li>调用外部函数：<code>Linker</code>、<code>FunctionDescriptor</code>和<code>SymbolLookup</code>。</li></ul><p>下面是 FFM API 使用示例，这段代码获取了 C 库函数的 <code>radixsort</code> 方法句柄，然后使用它对 Java 数组中的四个字符串进行排序。</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code><span class="token comment">// 1. 在C库路径上查找外部函数</span>
<span class="token class-name">Linker</span> linker <span class="token operator">=</span> <span class="token class-name">Linker</span><span class="token punctuation">.</span><span class="token function">nativeLinker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SymbolLookup</span> stdlib <span class="token operator">=</span> linker<span class="token punctuation">.</span><span class="token function">defaultLookup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MethodHandle</span> radixSort <span class="token operator">=</span> linker<span class="token punctuation">.</span><span class="token function">downcallHandle</span><span class="token punctuation">(</span>
                             stdlib<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token string">&quot;radixsort&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2. 分配堆上内存以存储四个字符串</span>
<span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> javaStrings   <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token string">&quot;mouse&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dog&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;car&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 3. 分配堆外内存以存储四个指针</span>
<span class="token class-name">SegmentAllocator</span> allocator <span class="token operator">=</span> <span class="token function">implicitAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">MemorySegment</span> offHeap  <span class="token operator">=</span> allocator<span class="token punctuation">.</span><span class="token function">allocateArray</span><span class="token punctuation">(</span><span class="token class-name">ValueLayout</span><span class="token punctuation">.</span><span class="token constant">ADDRESS</span><span class="token punctuation">,</span> javaStrings<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 4. 将字符串从堆上复制到堆外</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> javaStrings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在堆外分配一个字符串，然后存储指向它的指针</span>
    <span class="token class-name">MemorySegment</span> cString <span class="token operator">=</span> allocator<span class="token punctuation">.</span><span class="token function">allocateUtf8String</span><span class="token punctuation">(</span>javaStrings<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    offHeap<span class="token punctuation">.</span><span class="token function">setAtIndex</span><span class="token punctuation">(</span><span class="token class-name">ValueLayout</span><span class="token punctuation">.</span><span class="token constant">ADDRESS</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> cString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 5. 通过调用外部函数对堆外数据进行排序</span>
radixSort<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>offHeap<span class="token punctuation">,</span> javaStrings<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token class-name">MemoryAddress</span><span class="token punctuation">.</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token char">&#39;\\0&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 6. 将(重新排序的)字符串从堆外复制到堆上</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> javaStrings<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">MemoryAddress</span> cStringPtr <span class="token operator">=</span> offHeap<span class="token punctuation">.</span><span class="token function">getAtIndex</span><span class="token punctuation">(</span><span class="token class-name">ValueLayout</span><span class="token punctuation">.</span><span class="token constant">ADDRESS</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    javaStrings<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cStringPtr<span class="token punctuation">.</span><span class="token function">getUtf8String</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">assert</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>javaStrings<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">&quot;car&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;dog&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;mouse&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="jep-425-虚拟线程-预览" tabindex="-1"><a class="header-anchor" href="#jep-425-虚拟线程-预览"><span>JEP 425: 虚拟线程（预览）</span></a></h2><p>虚拟线程（Virtual Thread-）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><p>虚拟线程在其他多线程语言中已经被证实是十分有用的，比如 Go 中的 Goroutine、Erlang 中的进程。</p><p>虚拟线程避免了上下文切换的额外耗费，兼顾了多线程的优点，简化了高并发程序的复杂，可以有效减少编写、维护和观察高吞吐量并发应用程序的工作量。</p>`,9),K={href:"https://www.zhihu.com/question/536743167",target:"_blank",rel:"noopener noreferrer"},F=n("p",null,"Java 虚拟线程的详细解读和原理可以看下面这两篇文章：",-1),C={href:"https://mp.weixin.qq.com/s/yyApBXxpXxVwttr01Hld6Q",target:"_blank",rel:"noopener noreferrer"},R={href:"https://www.cnblogs.com/throwable/p/16758997.html",target:"_blank",rel:"noopener noreferrer"},H=n("h2",{id:"jep-426-向量-api-第四次孵化",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#jep-426-向量-api-第四次孵化"},[n("span",null,"JEP 426: 向量 API（第四次孵化）")])],-1),U={href:"https://openjdk.java.net/jeps/338",target:"_blank",rel:"noopener noreferrer"},Z={href:"http://openjdk.java.net/jeps/11",target:"_blank",rel:"noopener noreferrer"},z={href:"https://openjdk.java.net/jeps/414",target:"_blank",rel:"noopener noreferrer"},B={href:"https://openjdk.java.net/jeps/417",target:"_blank",rel:"noopener noreferrer"},G={href:"https://openjdk.java.net/jeps/426",target:"_blank",rel:"noopener noreferrer"},O=n("h2",{id:"jep-428-结构化并发-孵化",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#jep-428-结构化并发-孵化"},[n("span",null,"JEP 428: 结构化并发(孵化)")])],-1),X=n("p",null,[a("JDK 19 引入了结构化并发，一种多线程编程方法，目的是为了通过结构化并发 API 来简化多线程编程，并不是为了取代"),n("code",null,"java.util.concurrent"),a("，目前处于孵化器阶段。")],-1),Q=n("p",null,"结构化并发将不同线程中运行的多个任务视为单个工作单元，从而简化错误处理、提高可靠性并增强可观察性。也就是说，结构化并发保留了单线程代码的可读性、可维护性和可观察性。",-1),W={href:"https://download.java.net/java/early_access/loom/docs/api/jdk.incubator.concurrent/jdk/incubator/concurrent/StructuredTaskScope.html",target:"_blank",rel:"noopener noreferrer"},Y=n("code",null,"StructuredTaskScope",-1),$=n("code",null,"StructuredTaskScope",-1),nn=o(`<p><code>StructuredTaskScope</code> 的基本用法如下：</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="language-java"><code>    <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token keyword">var</span> scope <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StructuredTaskScope</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 使用fork方法派生线程来执行子任务</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> future1 <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>task1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future2 <span class="token operator">=</span> scope<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>task2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 等待线程完成</span>
        scope<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 结果的处理可能包括处理或重新抛出异常</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> process results<span class="token operator">/</span>exceptions <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token comment">// close</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结构化并发非常适合虚拟线程，虚拟线程是 JDK 实现的轻量级线程。许多虚拟线程共享同一个操作系统线程，从而允许非常多的虚拟线程。</p>`,3);function an(sn,tn){const t=e("ExternalLinkIcon"),p=e("RouteLink");return l(),r("div",null,[k,d,n("ul",null,[n("li",null,[n("a",h,[a("JEP 405: Record Patterns（记录模式）"),s(t)]),a("（预览）")]),n("li",null,[n("a",m,[a("JEP 422: Linux/RISC-V Port"),s(t)])]),n("li",null,[n("a",v,[a("JEP 424: Foreign Function & Memory API（外部函数和内存 API）"),s(t)]),a("（预览）")]),n("li",null,[n("a",_,[a("JEP 425: Virtual Threads（虚拟线程）"),s(t)]),a("（预览）")]),n("li",null,[n("a",g,[a("JEP 426: Vector（向量）API"),s(t)]),a("（第四次孵化）")]),n("li",null,[n("a",f,[a("JEP 427: Pattern Matching for switch（switch 模式匹配）"),s(t)])]),n("li",null,[n("a",j,[a("JEP 428: Structured Concurrency（结构化并发）"),s(t)]),a("（孵化）")])]),b,n("p",null,[a("相关阅读："),n("a",J,[a("OpenJDK Java 19 文档"),s(t)])]),P,y,n("p",null,[a("外部函数和内存 API 在 Java 17 中进行了第一轮孵化，由 "),n("a",S,[a("JEP 412"),s(t)]),a(" 提出。第二轮孵化由"),n("a",A,[a("JEP 419"),s(t)]),a(" 提出并集成到了 Java 18 中，预览由 "),n("a",w,[a("JEP 424"),s(t)]),a(" 提出并集成到了 Java 19 中。")]),I,n("ul",null,[n("li",null,[a("Java 通过 "),n("a",E,[x,s(t)]),a(" 提供一些执行低级别、不安全操作的方法（如直接访问系统内存资源、自主管理内存资源等），"),q,a(" 类让 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力的同时，也增加了 Java 语言的不安全性，不正确使用 "),D,a(" 类会使得程序出错的概率变大。")]),n("li",null,[a("Java 1.1 就已通过 Java 原生接口（JNI）支持了原生方法调用，但并不好用。JNI 实现起来过于复杂，步骤繁琐（具体的步骤可以参考这篇文章："),n("a",L,[a("Guide to JNI (Java Native Interface)"),s(t)]),a(" ），不受 JVM 的语言安全机制控制，影响 Java 语言的跨平台特性。并且，JNI 的性能也不行，因为 JNI 方法调用不能从许多常见的 JIT 优化(如内联)中受益。虽然"),n("a",T,[a("JNA"),s(t)]),a("、"),n("a",M,[a("JNR"),s(t)]),a("和"),n("a",N,[a("JavaCPP"),s(t)]),a("等框架对 JNI 进行了改进，但效果还是不太理想。")])]),V,n("p",null,[a("知乎有一个关于 Java 19 虚拟线程的讨论，感兴趣的可以去看看："),n("a",K,[a("zhihu-question-536743167"),s(t)]),a(" 。")]),F,n("ul",null,[n("li",null,[n("a",C,[a("Java19 正式 GA！看虚拟线程如何大幅提高系统吞吐量"),s(t)])]),n("li",null,[n("a",R,[a("虚拟线程 - VirtualThread源码透视"),s(t)])])]),H,n("p",null,[a("向量（Vector） API 最初由 "),n("a",U,[a("JEP 338"),s(t)]),a(" 提出，并作为"),n("a",Z,[a("孵化 API"),s(t)]),a("集成到 Java 16 中。第二轮孵化由 "),n("a",z,[a("JEP 414"),s(t)]),a(" 提出并集成到 Java 17 中，第三轮孵化由 "),n("a",B,[a("JEP 417"),s(t)]),a(" 提出并集成到 Java 18 中，第四轮由 "),n("a",G,[a("JEP 426"),s(t)]),a(" 提出并集成到了 Java 19 中。")]),n("p",null,[a("在 "),s(p,{to:"/java/new-features/java18.html"},{default:i(()=>[a("Java 18 新特性概览")]),_:1}),a(" 中，我有详细介绍到向量 API，这里就不再做额外的介绍了。")]),O,X,Q,n("p",null,[a("结构化并发的基本 API 是"),n("a",W,[Y,s(t)]),a("。"),$,a(" 支持将任务拆分为多个并发子任务，在它们自己的线程中执行，并且子任务必须在主任务继续之前完成。")]),nn])}const pn=c(u,[["render",an],["__file","java19.html.vue"]]),cn=JSON.parse('{"path":"/java/new-features/java19.html","title":"Java 19 新特性概览","lang":"zh-CN","frontmatter":{"icon":"java","title":"Java 19 新特性概览","category":"Java","headerDepth":5,"date":"2022-10-22T00:00:00.000Z","order":11,"tag":["Java新特性"],"description":"JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。","head":[["meta",{"property":"og:url","content":"https://blogres.github.io/java/new-features/java19.html"}],["meta",{"property":"og:title","content":"Java 19 新特性概览"}],["meta",{"property":"og:description","content":"JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-29T14:00:10.000Z"}],["meta",{"property":"article:author","content":"blogres"}],["meta",{"property":"article:tag","content":"Java新特性"}],["meta",{"property":"article:published_time","content":"2022-10-22T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-29T14:00:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 19 新特性概览\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-10-22T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-29T14:00:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"blogres\\",\\"url\\":\\"/article\\"}]}"]]},"headers":[{"level":2,"title":"JEP 424: 外部函数和内存 API（预览）","slug":"jep-424-外部函数和内存-api-预览","link":"#jep-424-外部函数和内存-api-预览","children":[]},{"level":2,"title":"JEP 425: 虚拟线程（预览）","slug":"jep-425-虚拟线程-预览","link":"#jep-425-虚拟线程-预览","children":[]},{"level":2,"title":"JEP 426: 向量 API（第四次孵化）","slug":"jep-426-向量-api-第四次孵化","link":"#jep-426-向量-api-第四次孵化","children":[]},{"level":2,"title":"JEP 428: 结构化并发(孵化)","slug":"jep-428-结构化并发-孵化","link":"#jep-428-结构化并发-孵化","children":[]}],"git":{"createdTime":1706536810000,"updatedTime":1706536810000,"contributors":[{"name":"topjfy","email":"topjfk@163.com","commits":1}]},"readingTime":{"minutes":5.64,"words":1691},"filePathRelative":"java/new-features/java19.md","localizedDate":"2022年10月22日","excerpt":"<p>JDK 19 定于 2022 年 9 月 20 日正式发布以供生产使用，非长期支持版本。不过，JDK 19 中有一些比较重要的新特性值得关注。</p>\\n","autoDesc":true}');export{pn as comp,cn as data};
